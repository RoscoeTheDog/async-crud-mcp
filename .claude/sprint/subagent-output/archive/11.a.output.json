{
  "story_id": "11",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-12T22:00:00Z",
  "planning_output": {
    "implementation_plan": "Implement two new MCP tools: async_list() for directory listing with glob filtering and optional hash attachment, and async_status() for querying server and per-file status. Both tools follow the established patterns from async_read/async_write: async function signature taking a Pydantic request model plus injected dependencies (path_validator, lock_manager, hash_registry, config/settings), returning Union of success/error response models.\n\n## async_list (src/async_crud_mcp/tools/async_list.py)\n\n1. Accept AsyncListRequest (already defined in models/requests.py with path, pattern, recursive, include_hashes fields)\n2. Validate path via PathValidator\n3. Verify directory exists (return DIR_NOT_FOUND ErrorResponse if not)\n4. Use os.scandir for non-recursive listing, os.walk for recursive listing\n5. Apply fnmatch glob filtering against the pattern field\n6. Build DirectoryEntry objects for each match (name, type, size_bytes, modified timestamp)\n7. If include_hashes=True, look up each file path in HashRegistry.get() and attach cached hash (null for untracked)\n8. No lock acquisition per PRD spec\n9. Return ListSuccessResponse\n\n## async_status (src/async_crud_mcp/tools/async_status.py)\n\n1. Accept AsyncStatusRequest (already defined in models/requests.py with optional path field)\n2. If path is None -> global status:\n   - Build ServerInfo from config/settings (version from __version__, uptime from server start_time, transport, port, persistence mode)\n   - Count tracked_files from HashRegistry snapshot length\n   - Count active_locks (read/write) from LockManager.get_all_status()\n   - Compute queue_depth from lock status queue counts\n   - Return GlobalStatusResponse\n3. If path is provided -> per-file status:\n   - Validate path via PathValidator\n   - Check file exists\n   - Get hash from HashRegistry\n   - Get lock status from LockManager.get_status()\n   - Build FileStatusResponse with lock_state, queue_depth, active_readers, pending_requests\n   - Return FileStatusResponse\n\n## Registration\n\nUpdate tools/__init__.py to export async_list and async_status.\n\n## Testing\n\nCreate tests/test_tools/test_async_list.py and tests/test_tools/test_async_status.py following the existing pytest-asyncio patterns with fixtures for temp_base_dir, path_validator, lock_manager, hash_registry.",
    "files_to_modify": [
      "src/async_crud_mcp/tools/async_list.py",
      "src/async_crud_mcp/tools/async_status.py",
      "src/async_crud_mcp/tools/__init__.py",
      "tests/test_tools/test_async_list.py",
      "tests/test_tools/test_async_status.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-11.1": "async_list with glob pattern filtering and recursive option: Create src/async_crud_mcp/tools/async_list.py. The function accepts AsyncListRequest (already defined with path, pattern, recursive, include_hashes). Steps: (1) Validate path with PathValidator, (2) Check os.path.isdir, return DIR_NOT_FOUND ErrorResponse if not, (3) For non-recursive: use os.scandir to get entries in directory, apply fnmatch.fnmatch(entry.name, pattern) filter, (4) For recursive: use os.walk to traverse subdirectories, apply fnmatch filter, build relative paths from the base directory, (5) For each matching entry build DirectoryEntry with name (relative path for recursive, basename for non-recursive), type ('file' or 'directory'), size_bytes (from stat for files, None for dirs), modified (ISO 8601 from mtime), (6) Return ListSuccessResponse with entries, total_entries count, pattern, recursive flag, and timestamp.",
      "AC-11.2": "async_list include_hashes attaches cached hashes: When request.include_hashes is True, for each file entry, look up the full resolved path in HashRegistry.get(). If the file has been previously tracked (read/written by the server), attach the cached hash string. If not tracked, set hash=None. This provides agents with known-good hashes without requiring per-file reads. The HashRegistry dependency is injected as a parameter to the async_list function, matching the pattern used in async_write.",
      "AC-11.3": "async_list no lock acquisition: Per PRD Section 3.8 and the lock table (Section 4), async_list acquires NO locks. The function directly performs os.scandir/os.walk without any lock_manager calls. This is a read-only directory snapshot; the PRD explicitly notes files may change between listing and subsequent operations. The lock_manager parameter is NOT included in the function signature at all (unlike async_read which takes shared locks).",
      "AC-11.4": "async_status global status (version, uptime, locks, queue): Create src/async_crud_mcp/tools/async_status.py. When request.path is None, return GlobalStatusResponse. Dependencies needed: (1) settings (Settings instance) for transport, port, persistence config, (2) server_start_time (float, monotonic or datetime) for uptime calculation, (3) hash_registry for tracked_files count via len(hash_registry.snapshot()), (4) lock_manager for active lock counts via get_all_status(). Build ServerInfo(version=__version__, uptime_seconds=time.monotonic()-start_time, transport=settings.daemon.transport, port=settings.daemon.port, persistence='enabled'/'disabled' based on settings.persistence.enabled). Compute ActiveLocks by summing active_readers and active_writer across all file locks from get_all_status(). Compute queue_depth by summing queued counts. Return GlobalStatusResponse with server info, tracked_files, active_locks, queue_depth, and base_directories from settings.crud.base_directories.",
      "AC-11.5": "async_status per-file status: When request.path is provided, validate with PathValidator, check os.path.exists for the exists field, get hash from HashRegistry.get() (None if untracked), get lock status from LockManager.get_status(path) which returns active_readers, active_writer, queued counts. Derive lock_state string: 'write_locked' if active_writer, 'read_locked' if active_readers > 0, else 'unlocked'. Build pending_requests list from the lock queue entries (requires access to FileLock queue - currently LockManager.get_status returns queued count but not queue details; may need to extend get_status or add a get_pending_requests method to expose request types and timestamps). Return FileStatusResponse."
    },
    "testing_strategy": "Create two test files following existing pytest-asyncio patterns:\n\n1. tests/test_tools/test_async_list.py:\n   - test_list_basic: Create temp dir with files, verify entries returned\n   - test_list_glob_pattern: Create mixed files, filter with *.py pattern\n   - test_list_recursive: Create nested dirs, verify recursive traversal\n   - test_list_recursive_with_pattern: Recursive + glob filter combined\n   - test_list_include_hashes_tracked: Pre-populate HashRegistry, verify hashes attached\n   - test_list_include_hashes_untracked: Files not in registry get hash=None\n   - test_list_empty_dir: Empty directory returns empty entries list\n   - test_list_dir_not_found: Non-existent dir returns DIR_NOT_FOUND error\n   - test_list_path_outside_base: Path traversal returns PATH_OUTSIDE_BASE error\n   - test_list_no_locks: Verify lock_manager is not called (mock verification)\n\n2. tests/test_tools/test_async_status.py:\n   - test_global_status_basic: Verify GlobalStatusResponse fields populated\n   - test_global_status_tracked_files: Add entries to HashRegistry, verify count\n   - test_global_status_active_locks: Acquire locks, verify counts in response\n   - test_file_status_exists: Create file, verify FileStatusResponse fields\n   - test_file_status_not_exists: Non-existent file returns exists=False\n   - test_file_status_with_hash: File in HashRegistry shows hash\n   - test_file_status_locked: Acquire lock, verify lock_state reflects it\n   - test_file_status_path_validation: Invalid path returns PATH_OUTSIDE_BASE\n\nAll tests use temp directories, PathValidator scoped to temp dir, fresh LockManager and HashRegistry instances per test. Use pytest-asyncio auto mode (configured in pyproject.toml).",
    "dependencies": []
  }
}
