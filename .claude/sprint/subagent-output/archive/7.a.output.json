{
  "story_id": "7",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-13T03:30:00Z",
  "planning_output": {
    "implementation_plan": "Create the diff engine module (core/diff_engine.py) that computes differences between two file content strings using Python's difflib. The module provides two output formats: JSON (structured, agent-friendly with change regions) and unified (standard git-diff style). Both formats include a DiffSummary with line counts. Context lines are configurable (default from config.crud.diff_context_lines=3). The module exposes a single primary function compute_diff() that accepts old_content, new_content, diff_format, and context_lines, returning the appropriate Pydantic model (JsonDiff or UnifiedDiff). This function will be called by the contention detection logic in file_io / tool handlers when a hash mismatch is detected during update/delete/rename operations. The module also needs a helper to analyze patch applicability for contention responses (which patches from an update request can still apply to the changed file). Tests cover all edge cases: identical content, empty files, single-line changes, multi-line additions/removals/modifications, context line configuration, unified format correctness, and patch applicability analysis.",
    "files_to_modify": [
      "src/async_crud_mcp/core/diff_engine.py",
      "src/async_crud_mcp/core/__init__.py",
      "tests/test_diff_engine.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-7.1": "JSON diff with change regions (added/removed/modified): Implement compute_json_diff() using difflib.SequenceMatcher to identify opcodes (equal/insert/delete/replace). Map opcodes to DiffChange objects: 'insert' -> type='added', 'delete' -> type='removed', 'replace' -> type='modified'. Each DiffChange includes start_line, end_line, old_content (for removed/modified), new_content (for added/modified), and context_before/context_after extracted from surrounding equal blocks. Return a JsonDiff model with the list of changes and a computed DiffSummary.",
      "AC-7.2": "Unified diff format (standard git diff style): Implement compute_unified_diff() using difflib.unified_diff() with fromfile='expected', tofile='current' labels. Pass the context_lines parameter as the 'n' argument to unified_diff(). Parse the output to compute summary statistics (lines added/removed/modified, region count) by counting +/- lines and @@ hunks. Return a UnifiedDiff model with the full diff text as 'content' and the computed DiffSummary.",
      "AC-7.3": "Configurable context lines: The compute_diff() function accepts an optional context_lines parameter (int, default=3 matching CrudConfig.diff_context_lines). For JSON format, context lines are extracted from equal opcodes adjacent to change regions. For unified format, context_lines is passed directly to difflib.unified_diff(n=context_lines). The caller (file_io/tool handlers) will pass the configured value from Settings.crud.diff_context_lines.",
      "AC-7.4": "Summary with line counts and region count: Both formats return a DiffSummary with lines_added, lines_removed, lines_modified, and regions_changed. For JSON format, counts are computed directly from the DiffChange list. For unified format, counts are parsed from the diff output: lines starting with '+' (not '+++') are added, '-' (not '---') are removed; lines that appear in replace opcodes (or adjacent +/- pairs) count as modified; regions_changed equals the number of @@ hunk headers. The DiffSummary model is already defined in responses.py.",
      "AC-7.5": "Uses Python difflib: All diff computation uses the stdlib difflib module. SequenceMatcher for JSON format (provides opcodes for structured change analysis), unified_diff() for unified format. No external diff library dependencies needed. difflib operates on lists of strings (lines), so input content is split on newlines before processing."
    },
    "testing_strategy": "Create tests/test_diff_engine.py with comprehensive test cases:\n\n1. **Identical content**: Both formats return empty changes/no diff, summary all zeros\n2. **Empty old content (new file scenario)**: All lines are 'added'\n3. **Empty new content (deletion scenario)**: All lines are 'removed'\n4. **Single line change**: One 'modified' region\n5. **Multi-line addition**: Lines inserted in the middle\n6. **Multi-line removal**: Lines removed from the middle\n7. **Mixed changes**: Combination of adds, removes, and modifications in one diff\n8. **Context lines = 0**: No context lines included\n9. **Context lines = 5**: More context than default\n10. **Unified diff format correctness**: Verify output matches expected unified diff text, includes proper --- +++ headers and @@ hunk markers\n11. **Summary accuracy**: Verify line counts and region counts match expected values for all test cases\n12. **Patch applicability helper**: Test check_patch_applicability() with patches that can/cannot apply to changed content\n13. **Large file performance**: Verify reasonable performance on files with 1000+ lines\n14. **Trailing newline handling**: Files with/without trailing newlines produce correct diffs\n\nAll tests are synchronous (difflib is sync). Use pytest parametrize for format variants where applicable.",
    "dependencies": []
  }
}
