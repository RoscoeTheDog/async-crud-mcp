{
  "story_id": "9",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-12T22:30:00Z",
  "planning_output": {
    "implementation_plan": "Implement async_update() MCP tool in src/async_crud_mcp/tools/async_update.py with hash-based contention detection and diff-based contention response. The tool follows the established pattern from async_write (validate path -> check exists -> acquire lock -> hash comparison -> apply update or return contention -> release lock). Two update modes: full content replacement and patch mode (old_string/new_string pairs). On hash mismatch, returns ContentionResponse with diff (JSON or unified) and patch applicability analysis.\n\nKey design decisions:\n1. Follow async_write pattern: path validation, lock acquisition with timeout, double-check inside lock\n2. Hash comparison uses compute_hash on raw bytes read from disk (same as async_read)\n3. For content mode: straightforward atomic_write replacement\n4. For patch mode: sequential string replacement of old_string->new_string pairs, fail on first miss with INVALID_PATCH\n5. Contention response: compute diff between expected content (what agent thought file was) and current content (what file actually is). For patch mode, also check which patches are still applicable to current content using simple string-find (not the subprocess-based check_patch_applicability which expects unified diff format)\n6. Register tools/__init__.py export after implementation",
    "files_to_modify": [
      "src/async_crud_mcp/tools/async_update.py",
      "src/async_crud_mcp/tools/__init__.py",
      "tests/test_tools/test_async_update.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-9.1": "Hash comparison for contention detection: Read file as raw bytes inside exclusive write lock, compute_hash(raw_bytes), compare to request.expected_hash. If mismatch, build ContentionResponse with diff between expected and current content. If match, proceed with update. The expected content for the diff is reconstructed by: the agent's expected_hash represents the content they last read. Since we don't store the expected content, we compute diff between what was on disk when expected_hash was valid vs what's on disk now. In practice, we only have current content. The diff in the contention response shows changes FROM what the agent expected TO what the file currently is. We need to read current content and we use compute_diff(expected_content, current_content). IMPORTANT: We do NOT have the expected content (only its hash). The PRD diff shows old_content as 'expected' and new_content as 'current'. Since we cannot reconstruct expected content from the hash alone, the contention response provides current_hash and the diff is computed from the agent's submitted content/patches perspective. CORRECTION: Re-reading the PRD more carefully, the diff is between 'the version the agent expected' and 'the current version'. The agent doesn't send expected content, only expected_hash. The server cannot reconstruct expected content from hash. The actual implementation approach: when content mode is used, the agent sends new content (not expected content). When patches mode is used, the agent sends old_string/new_string pairs. In both cases, the contention response should show what changed in the file between when the agent last read it and now. Since we only have current content (not the agent's expected version), the diff is computed between the content the agent intended to write and the current file content - NO. Re-reading PRD: the diff shows changes between what the agent expected the file to be vs what it actually is. We don't have the expected content. However, we can note that HashRegistry may have a stored hash but not content. The practical solution used by the existing check_patch_applicability and the PRD examples: the diff compares 'expected' (what agent thought) vs 'current' (what file is). Since the server doesn't store old file versions, and the agent only sends the hash, the diff must be computed differently. Looking at the PRD response example: the diff labels are 'expected' and 'current'. In content mode: if the agent sends full content, we can diff the agent's intended new content vs current file content to show why the update would be wrong. But the PRD says the diff shows what changed SINCE the agent last read the file, not what the agent wants to write. The simplest correct approach: the contention response returns current_hash and tells the agent 'the file changed'. The agent should re-read the file with async_read() to get the new content. The diff in the response is a convenience showing what changed. Since we don't have the old content, we should compute the diff between the content the agent's patches would produce (or the content they want to write) and the current file. Actually, looking at the unified diff example in the PRD: fromfile='expected', tofile='current'. This means: 'expected' = what the agent expected the file to look like, 'current' = what file actually is. For patch mode, the agent expected the file to have old_string values at certain locations. For content mode, the agent expected the hash to match. In both cases, the 'expected' version is the file content at the time of the agent's last read, which we don't have. RESOLUTION: The diff engine already exists and takes old_content and new_content. We need to recover the old content. The only way is: (1) if content mode, the agent is sending replacement content, not the old content - so we can't diff. (2) if patch mode, we could try to reverse-apply patches to get old content from current, but that's fragile. PRACTICAL APPROACH: Store nothing extra. When contention occurs, return current_content's hash and a message. The agent re-reads with async_read() to get fresh content. The diff between 'expected' and 'current' CANNOT be computed without the expected content. HOWEVER: the PRD clearly specifies a diff in the response. Looking at similar systems (Claude Code's Edit tool), the pattern is: agent reads file (gets hash H1), agent sends update with expected_hash=H1, server finds file has hash H2!=H1, server has current content (hash H2) but not content at H1. The only viable approach: we must store previous file content somewhere, OR we accept that the diff will be between the agent's submitted content and current content. Given HashRegistry only stores hashes, not content, and the PRD doesn't mention a content cache, the practical answer is: compute diff between the UPDATE CONTENT the agent submitted and the current file content. For content mode: diff(request.content, current_content). For patch mode: diff is less meaningful since patches are targeted. Instead just report which patches can/cannot apply. Final decision: For contention, diff shows what the CURRENT file looks like compared to what the agent WANTED to write. This is useful because it tells the agent how their intended change relates to the actual file state.",
      "AC-9.2": "Full content replacement mode: When request.content is provided and hash matches, encode content to bytes using request.encoding, call atomic_write(validated_path, encoded_bytes), compute new hash, update HashRegistry, return UpdateSuccessResponse with previous_hash, new hash, bytes_written, timestamp. Pattern matches async_write exactly.",
      "AC-9.3": "Patch mode with old_string/new_string pairs: When request.patches is provided and hash matches, read current content as string, iterate through patches sequentially applying str.replace(old_string, new_string, 1) (replace first occurrence only). If any old_string is not found in the current content, return ErrorResponse with INVALID_PATCH error code, indicating which patch index failed and the old_string that wasn't found. After all patches applied successfully, encode result, atomic_write, compute hash, update registry, return UpdateSuccessResponse.",
      "AC-9.4": "Contention response with JSON or unified diff: On hash mismatch, decode current file content using request.encoding, and compute diff. For content mode: diff between agent's submitted content and current content (compute_diff(request.content, current_content, diff_format)). For patch mode: since agent didn't send full expected content, we provide the diff between what applying the patches to current content would produce vs current content, along with patch applicability. Use compute_diff() from core.diff_engine which already supports both 'json' and 'unified' formats based on request.diff_format. Build ContentionResponse with expected_hash, current_hash, message, diff, and timestamp.",
      "AC-9.5": "patches_applicable, conflicts, non_conflicting_patches fields: Only populated when request used patches mode. Check each patch's old_string against current file content using simple string-find (not subprocess). If old_string is found in current content, patch is applicable (add to non_conflicting_patches list). If not found, create PatchConflict with patch_index and reason='old_string not found in current file content'. Set patches_applicable=True only if ALL patches are applicable (conflicts list is empty). These fields are None when content mode was used.",
      "AC-9.6": "CONTENT_OR_PATCHES_REQUIRED error: Already handled by the Pydantic model_validator on AsyncUpdateRequest which raises ValueError when neither content nor patches is provided. The MCP framework will convert this to a validation error before the tool function is called. However, as defense in depth, add an explicit check at the start of the tool function: if request.content is None and request.patches is None, return ErrorResponse with CONTENT_OR_PATCHES_REQUIRED error code."
    },
    "testing_strategy": "Create tests/test_tools/test_async_update.py following the pattern from test_async_write.py. Test classes:\n\n1. TestAsyncUpdateContentSuccess - Full content replacement:\n   - test_update_existing_file: Create file, read hash, update with new content, verify success response fields\n   - test_update_returns_previous_and_new_hash: Verify previous_hash matches original, hash matches new content\n   - test_update_writes_content_to_disk: Verify file on disk matches new content after update\n   - test_update_updates_hash_registry: Verify HashRegistry is updated with new hash\n   - test_update_bytes_written_correct: Verify bytes_written matches encoded content length\n\n2. TestAsyncUpdatePatchSuccess - Patch mode:\n   - test_single_patch_applied: One old_string/new_string pair, verify replacement\n   - test_multiple_patches_applied_sequentially: Multiple patches applied in order\n   - test_patch_replaces_first_occurrence: Verify only first match is replaced per patch\n\n3. TestAsyncUpdateContention - Hash mismatch:\n   - test_contention_on_hash_mismatch_content_mode: Modify file externally, attempt update, verify ContentionResponse\n   - test_contention_json_diff_format: Verify JSON diff structure\n   - test_contention_unified_diff_format: Verify unified diff content\n   - test_contention_patches_applicable_true: All patches still apply to modified file\n   - test_contention_patches_applicable_false: Some patches conflict\n   - test_contention_non_conflicting_patches: Verify correct indices returned\n   - test_contention_does_not_modify_file: Verify file unchanged after contention\n\n4. TestAsyncUpdateErrors:\n   - test_file_not_found: Update non-existent file\n   - test_path_outside_base: Path validation failure\n   - test_invalid_patch_old_string_not_found: Patch with missing old_string\n   - test_lock_timeout: Lock held by another operation\n   - test_content_or_patches_required: Neither content nor patches (defense in depth)\n\n5. TestAsyncUpdateConcurrency:\n   - test_exclusive_lock_blocks_concurrent_updates: Two concurrent updates, one gets lock timeout\n\nFixtures: temp_base_dir, path_validator, lock_manager, hash_registry (same pattern as test_async_write.py). Helper to create a file and return its hash.",
    "dependencies": []
  }
}
