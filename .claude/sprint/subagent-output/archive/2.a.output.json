{
  "story_id": "2",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-17T07:15:00Z",
  "planning_output": {
    "implementation_plan": "Add an HTTP GET /health endpoint to server.py using FastMCP's `custom_route` decorator. This endpoint returns JSON with status, version, and uptime fields via plain HTTP (not MCP protocol). The existing `check_health()` function from `daemon/health.py` already provides the core health data; the new route reuses it and enriches with version/uptime, mirroring the existing `health_tool()` MCP tool logic. The endpoint returns HTTP 200 for healthy/degraded status and HTTP 503 for unhealthy status. The `scripts/test_server.py` already expects this endpoint at `/health` (line 300) so AC-2.4 is already satisfied once the endpoint exists. Unit tests will be added to `tests/test_server.py` to verify the new route.",
    "files_to_modify": [
      "src/async_crud_mcp/server.py",
      "tests/test_server.py"
    ],
    "estimated_complexity": "low",
    "ac_breakdown": {
      "AC-2.1": "Add `@mcp.custom_route('/health', methods=['GET'])` handler that calls `check_health()`, enriches with `version` (from `__version__`) and `uptime` (from `server_start_time`), and returns the result as a Starlette `JSONResponse`. Response JSON contains: status (healthy|degraded|unhealthy), version (string), uptime (float seconds), plus existing health fields (config_readable, daemon_enabled, logs_dir_exists, port_listening, host, port, message). File: `src/async_crud_mcp/server.py`. Add import for `starlette.requests.Request` and `starlette.responses.JSONResponse` (already transitive deps via FastMCP).",
      "AC-2.2": "The `custom_route` decorator registers a plain HTTP route on the Starlette ASGI app that FastMCP builds for SSE transport. This route is accessible via standard HTTP GET without any MCP protocol handshake. No additional work needed beyond using `custom_route`.",
      "AC-2.3": "In the handler, check `health_data['status']`: if `'unhealthy'` return `JSONResponse(health_data, status_code=503)`, otherwise return `JSONResponse(health_data, status_code=200)`. This maps healthy/degraded to 200 and unhealthy to 503.",
      "AC-2.4": "`scripts/test_server.py` `check_server_connectivity()` (line 272-317) already makes an HTTP GET to `http://{host}:{port}/health` and checks for 200 response. Once the endpoint exists, this test script will work. No changes needed to `scripts/test_server.py`. For unit tests, add a test class in `tests/test_server.py` that verifies the custom route is registered and the handler returns correct status codes."
    },
    "testing_strategy": "Add a `TestHealthEndpoint` class in `tests/test_server.py` with tests: (1) Verify the `/health` route is registered in `mcp._additional_http_routes`. (2) Test the health endpoint handler function directly by constructing a mock Starlette Request and verifying it returns JSONResponse with correct fields (status, version, uptime). (3) Test that unhealthy status returns 503 by mocking `check_health()` to return unhealthy status. (4) Test that healthy status returns 200. The existing `scripts/test_server.py` integration test already covers AC-2.4 and needs no changes.",
    "dependencies": []
  }
}
