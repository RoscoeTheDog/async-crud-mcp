{
  "story_id": "3",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-13T03:30:00Z",
  "planning_output": {
    "implementation_plan": "Create all Pydantic v2 models for MCP tool parameters and responses in two files: src/async_crud_mcp/models/requests.py and src/async_crud_mcp/models/responses.py. Update models/__init__.py to re-export all public models.\n\n## requests.py\n\nDefine request models for all 11 MCP tools using Pydantic BaseModel with strict field typing:\n\n1. **AsyncReadRequest**: path (str), offset (int, default=0), limit (int | None, default=None), encoding (str, default='utf-8')\n2. **AsyncWriteRequest**: path (str), content (str), encoding (str, default='utf-8'), create_dirs (bool, default=True), timeout (float, default=30.0)\n3. **AsyncUpdateRequest**: path (str), expected_hash (str), content (str | None, default=None), patches (list[Patch] | None, default=None), encoding (str, default='utf-8'), timeout (float, default=30.0), diff_format (Literal['json', 'unified'], default='json') -- with model_validator to enforce mutually exclusive content/patches\n4. **AsyncDeleteRequest**: path (str), expected_hash (str | None, default=None), timeout (float, default=30.0), diff_format (Literal['json', 'unified'], default='json')\n5. **AsyncRenameRequest**: old_path (str), new_path (str), expected_hash (str | None, default=None), overwrite (bool, default=False), create_dirs (bool, default=True), timeout (float, default=30.0), diff_format (Literal['json', 'unified'], default='json')\n6. **AsyncAppendRequest**: path (str), content (str), encoding (str, default='utf-8'), create_if_missing (bool, default=False), create_dirs (bool, default=True), separator (str, default=''), timeout (float, default=30.0)\n7. **AsyncListRequest**: path (str), pattern (str, default='*'), recursive (bool, default=False), include_hashes (bool, default=False)\n8. **AsyncStatusRequest**: path (str | None, default=None)\n9. **AsyncBatchReadRequest**: files (list[BatchReadItem])\n10. **AsyncBatchWriteRequest**: files (list[BatchWriteItem]), timeout (float, default=30.0)\n11. **AsyncBatchUpdateRequest**: files (list[BatchUpdateItem]), timeout (float, default=30.0), diff_format (Literal['json', 'unified'], default='json')\n\nSupporting models:\n- **Patch**: old_string (str), new_string (str)\n- **BatchReadItem**: path (str), offset (int, default=0), limit (int | None, default=None), encoding (str, default='utf-8')\n- **BatchWriteItem**: path (str), content (str), encoding (str, default='utf-8'), create_dirs (bool, default=True)\n- **BatchUpdateItem**: path (str), expected_hash (str), content (str | None, default=None), patches (list[Patch] | None, default=None), encoding (str, default='utf-8') -- with same mutually exclusive validation as AsyncUpdateRequest\n\n## responses.py\n\nDefine response models grouped by category:\n\n### Success responses\n- **ReadSuccessResponse**: status (Literal['ok']), path (str), content (str), encoding (str), hash (str), total_lines (int), offset (int), limit (int | None), lines_returned (int), timestamp (str)\n- **WriteSuccessResponse**: status (Literal['ok']), path (str), hash (str), bytes_written (int), timestamp (str)\n- **UpdateSuccessResponse**: status (Literal['ok']), path (str), previous_hash (str), hash (str), bytes_written (int), timestamp (str)\n- **DeleteSuccessResponse**: status (Literal['ok']), path (str), deleted_hash (str), timestamp (str)\n- **RenameSuccessResponse**: status (Literal['ok']), old_path (str), new_path (str), hash (str), timestamp (str), cross_filesystem (bool, default=False)\n- **AppendSuccessResponse**: status (Literal['ok']), path (str), hash (str), bytes_appended (int), total_size_bytes (int), timestamp (str)\n- **ListSuccessResponse**: status (Literal['ok']), path (str), entries (list[DirectoryEntry]), total_entries (int), pattern (str), recursive (bool), timestamp (str)\n\n### Error response\n- **ErrorResponse**: status (Literal['error']), error_code (str), message (str), path (str | None, default=None), details (dict | None, default=None)\n\nUse a string enum **ErrorCode** for all error codes: FILE_NOT_FOUND, FILE_EXISTS, ACCESS_DENIED, PATH_OUTSIDE_BASE, LOCK_TIMEOUT, ENCODING_ERROR, INVALID_PATCH, CONTENT_OR_PATCHES_REQUIRED, FILE_TOO_LARGE, WRITE_ERROR, DELETE_ERROR, RENAME_ERROR, DIR_NOT_FOUND, SERVER_ERROR\n\n### Contention response\n- **DiffChange**: type (Literal['added', 'removed', 'modified']), start_line (int), end_line (int | None, default=None), old_content (str | None, default=None), new_content (str | None, default=None), context_before (str | None, default=None), context_after (str | None, default=None)\n- **DiffSummary**: lines_added (int), lines_removed (int), lines_modified (int), regions_changed (int)\n- **JsonDiff**: format (Literal['json']), changes (list[DiffChange]), summary (DiffSummary)\n- **UnifiedDiff**: format (Literal['unified']), content (str), summary (DiffSummary)\n- **PatchConflict**: patch_index (int), reason (str)\n- **ContentionResponse**: status (Literal['contention']), path (str), expected_hash (str), current_hash (str), message (str), diff (JsonDiff | UnifiedDiff), patches_applicable (bool | None, default=None), conflicts (list[PatchConflict] | None, default=None), non_conflicting_patches (list[int] | None, default=None), timestamp (str)\n\n### Status responses\n- **ServerInfo**: version (str), uptime_seconds (float), transport (str), port (int), persistence (str)\n- **ActiveLocks**: read (int), write (int)\n- **GlobalStatusResponse**: status (Literal['ok']), server (ServerInfo), tracked_files (int), active_locks (ActiveLocks), queue_depth (int), base_directories (list[str])\n- **PendingRequest**: type (str), queued_at (str), timeout_at (str)\n- **FileStatusResponse**: status (Literal['ok']), path (str), exists (bool), hash (str | None), lock_state (str), queue_depth (int), active_readers (int), pending_requests (list[PendingRequest])\n\n### Batch responses\n- **BatchSummary**: total (int), succeeded (int), failed (int), contention (int, default=0)\n- **BatchReadResponse**: status (Literal['ok']), results (list[ReadSuccessResponse | ErrorResponse]), summary (BatchSummary)\n- **BatchWriteResponse**: status (Literal['ok']), results (list[WriteSuccessResponse | ErrorResponse]), summary (BatchSummary)\n- **BatchUpdateResponse**: status (Literal['ok']), results (list[UpdateSuccessResponse | ContentionResponse | ErrorResponse]), summary (BatchSummary)\n\n### Directory entry\n- **DirectoryEntry**: name (str), type (Literal['file', 'directory']), size_bytes (int | None, default=None), modified (str | None, default=None), hash (str | None, default=None)\n\n## models/__init__.py\n\nRe-export all public models from requests and responses for convenient imports.\n\n## Design Decisions\n\n1. Use `Literal` types for status fields to enable discriminated unions\n2. Use `model_validator(mode='after')` for mutually exclusive content/patches on AsyncUpdateRequest and BatchUpdateItem\n3. Use `datetime` strings (ISO 8601) as str type rather than datetime objects, since these are JSON-serialized MCP responses\n4. Use `str` for hash fields (format: 'sha256:...') rather than a custom type\n5. Use `StrEnum` for ErrorCode for type safety and string compatibility\n6. Use Pydantic v2 model_config with `frozen=True` for immutable response models",
    "files_to_modify": [
      "src/async_crud_mcp/models/requests.py",
      "src/async_crud_mcp/models/responses.py",
      "src/async_crud_mcp/models/__init__.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-3.1": "Create request models for all 11 MCP tools in requests.py: AsyncReadRequest, AsyncWriteRequest, AsyncUpdateRequest, AsyncDeleteRequest, AsyncRenameRequest, AsyncAppendRequest, AsyncListRequest, AsyncStatusRequest, AsyncBatchReadRequest, AsyncBatchWriteRequest, AsyncBatchUpdateRequest. Each model maps exactly to the PRD Section 3 parameter tables. Supporting models: BatchReadItem, BatchWriteItem, BatchUpdateItem.",
      "AC-3.2": "Create a Patch model with old_string (str) and new_string (str) fields. Used by AsyncUpdateRequest.patches and BatchUpdateItem.patches. The model is defined in requests.py since it is an input type.",
      "AC-3.3": "Create three response categories in responses.py: (1) Success responses - one per tool with fields matching PRD response schemas (ReadSuccessResponse, WriteSuccessResponse, UpdateSuccessResponse, DeleteSuccessResponse, RenameSuccessResponse, AppendSuccessResponse, ListSuccessResponse). (2) ErrorResponse - unified error model with error_code (ErrorCode enum), message, optional path and details. (3) ContentionResponse - full contention model with diff (JsonDiff | UnifiedDiff discriminated union), patch applicability fields, conflicts list, non_conflicting_patches list.",
      "AC-3.4": "Create diff models in responses.py: DiffChange (type: added/removed/modified, line numbers, old/new content, context), DiffSummary (counts), JsonDiff (format='json', changes list, summary), UnifiedDiff (format='unified', content string, summary). Use discriminated union (Annotated[JsonDiff | UnifiedDiff, Field(discriminator='format')]) for the ContentionResponse.diff field.",
      "AC-3.5": "Create batch response models: BatchSummary (total, succeeded, failed, contention), BatchReadResponse, BatchWriteResponse, BatchUpdateResponse. Each batch response has a results list accepting per-item success/error/contention responses and a summary field. BatchUpdateResponse.summary includes the contention count field.",
      "AC-3.6": "Add @model_validator(mode='after') to AsyncUpdateRequest and BatchUpdateItem that raises ValueError if both content and patches are provided, or if neither is provided. Validation message: 'Exactly one of content or patches must be provided'. This enforces the mutually exclusive constraint from PRD Section 3.3."
    },
    "testing_strategy": "Create tests/test_models.py with: (1) Unit tests for each request model verifying default values and required fields. (2) Tests for Patch model construction. (3) Tests for mutually exclusive content/patches validation - verify both provided raises ValueError, neither provided raises ValueError, each alone succeeds. (4) Tests for response model construction with sample data matching PRD response schemas. (5) Tests for ErrorCode enum values matching PRD Section 7.1 error code registry. (6) Tests for diff model construction (both JSON and unified format). (7) Tests for batch response model with mixed success/error results. (8) Tests for discriminated union deserialization of diff field. All tests should verify model_dump() output matches expected JSON structure.",
    "dependencies": []
  }
}
