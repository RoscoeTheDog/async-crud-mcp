{
  "story_id": "4",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-13T09:15:00Z",
  "planning_output": {
    "implementation_plan": "Refactor daemon_cmd.py from direct process control to config-file-mutation pattern (ADR-003). The daemon is managed by BootstrapDaemon which polls config.json; CLI commands should mutate daemon.enabled in the config file and let the daemon react, rather than spawning/killing processes directly.\n\nKey pattern: Use atomic_write_config() from config_watcher.py and get_config_file_path() from paths.py. Load existing config JSON, modify daemon.enabled field, write back atomically. This is the same pattern the daemon's ConfigWatcher monitors for changes.\n\nFor start/stop/restart: Read config.json, set daemon.enabled=true/false, write back with atomic_write_config(). For restart: set false, wait (configurable via config_poll_seconds, default 3s + debounce 1s = ~4s), then set true.\n\nFor status: Add --username (resolve per-user config via get_user_config_file_path), --all (check all known users), --json (output raw JSON dict instead of Rich panel).\n\nFor logs: Add --lines (tail N lines), --username/--user (resolve per-user log dirs). On Windows, check ProgramData path via get_user_logs_dir() for service per-user logs.\n\nAll new options use typer.Option() with short flags matching spec conventions. Tests mock config file I/O and atomic_write_config.",
    "files_to_modify": [
      "src/async_crud_mcp/cli/daemon_cmd.py",
      "tests/test_cli/test_daemon_cmd.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-4.1": "Refactor start() command: Remove direct subprocess.Popen logic and BootstrapDaemon().run() call. Instead: (1) Import get_config_file_path from daemon.paths and atomic_write_config from daemon.config_watcher. (2) Load existing config JSON from get_config_file_path(). If file doesn't exist, create default via generate_default_config() from config_init. (3) Set config['daemon']['enabled'] = True. (4) Write back with atomic_write_config(config_path, config). (5) Print success message. The BootstrapDaemon's ConfigWatcher will detect the change and start the MCP server. Remove the --background option since config mutation is inherently async. Remove imports: asyncio, subprocess, sys, BootstrapDaemon.",
      "AC-4.2": "Refactor stop() command: Same config mutation pattern as start but set daemon.enabled=false. (1) Load config from get_config_file_path(). (2) Set config['daemon']['enabled'] = False. (3) Write back with atomic_write_config(). (4) Print confirmation. The daemon's ConfigWatcher will detect the change and stop the MCP server process. If config file doesn't exist, print warning and exit with code 1.",
      "AC-4.3": "Refactor restart() command: (1) Load config, set daemon.enabled=False, atomic_write_config(). (2) Wait for daemon to detect change and shut down - sleep for config_poll_seconds + debounce_seconds (read from config or use defaults: 3 + 1 = 4 seconds). (3) Set daemon.enabled=True, atomic_write_config(). (4) Print status messages for each phase. Use time.sleep() for the wait. Import time module.",
      "AC-4.4": "Add options to status() command: (1) --username/-u (str|None): If provided, resolve per-user config via get_user_config_file_path(username) from paths.py, then run health check against that config's host:port. (2) --all/-a (bool): If true, enumerate known user configs (list ProgramData/{APP_NAME}/logs/ subdirectories as proxy for known users on Windows, or just show current user status on Unix). (3) --json/-j (bool): If true, output check_health() result as raw JSON via json.dumps() instead of Rich Panel. Keep existing Rich panel output as default. Import json module (already available in config_watcher). For --username, create a helper _check_user_health(username) that loads user config and checks connectivity.",
      "AC-4.5": "Add options to logs() command: (1) --lines/-n (int|None, default None = show all): If set, only show last N lines of log file using deque(f, maxlen=lines) or f.readlines()[-lines:]. (2) --username/-u (str|None): Resolve per-user log directory using get_user_logs_dir(username) from paths.py. (3) --user (str|None): Alias for --username for convenience. If either --username or --user is provided, look up that user's log dir. The --follow flag already exists. When --lines is used with --follow, show last N lines then continue following.",
      "AC-4.6": "In the logs command, when --username/--user is provided on Windows: Use get_user_logs_dir(username) from daemon.paths which returns ProgramData/{APP_NAME}/logs/{username}. This is the path where the Multi-User Dispatcher writes per-user daemon logs. Check if the directory and daemon.log file exist within it. Also import get_user_logs_dir in the module-level imports."
    },
    "testing_strategy": "Expand tests/test_cli/test_daemon_cmd.py with the following test cases:\n\n1. test_start_mutates_config: Mock get_config_file_path, mock Path.exists (config exists), mock json.loads to return a config dict, mock atomic_write_config. Invoke 'start', assert atomic_write_config called with daemon.enabled=True.\n\n2. test_start_creates_config_if_missing: Mock config path not existing, verify generate_default_config is called and config written with enabled=True.\n\n3. test_stop_mutates_config: Similar to start but assert daemon.enabled=False.\n\n4. test_stop_no_config_exits: Mock config not existing, verify exit code 1.\n\n5. test_restart_cycles_enabled: Mock atomic_write_config, mock time.sleep. Assert two writes: first with enabled=False, second with enabled=True. Assert sleep called with appropriate wait time.\n\n6. test_status_json_output: Mock check_health, invoke with --json, assert output is valid JSON.\n\n7. test_status_username: Mock get_user_config_file_path, mock check_health, invoke with --username testuser.\n\n8. test_logs_lines: Mock log file with 100 lines, invoke with --lines 10, verify only 10 lines shown.\n\n9. test_logs_username: Mock get_user_logs_dir, invoke with --username testuser, verify correct path used.\n\nAll tests use typer.testing.CliRunner and unittest.mock patches.",
    "dependencies": []
  }
}
