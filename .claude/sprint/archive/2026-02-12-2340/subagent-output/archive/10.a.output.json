{
  "story_id": "10",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-12T22:00:00Z",
  "planning_output": {
    "implementation_plan": "Implement three new MCP tools (async_delete, async_rename, async_append) following the established patterns from async_read.py and async_write.py. Each tool is an async function accepting a Pydantic request model plus injected dependencies (PathValidator, LockManager, HashRegistry), returning a typed success/error/contention response.\n\n## async_delete (src/async_crud_mcp/tools/async_delete.py)\n1. Validate path via PathValidator\n2. Check file exists (FILE_NOT_FOUND if not)\n3. Acquire exclusive write lock with timeout (FIFO)\n4. If expected_hash provided: read file bytes, compute hash, compare. On mismatch, use diff_engine.compute_diff() to build ContentionResponse with diff between expected content and current content. Since delete doesn't have the 'expected content' directly, we read current file, compute hash, and if hash != expected_hash, we produce a contention response showing the file has changed. Release lock and return contention.\n5. If no expected_hash or hash matches: delete file via os.unlink()\n6. Record deleted_hash, remove from HashRegistry\n7. Release write lock\n8. Return DeleteSuccessResponse\n\n## async_rename (src/async_crud_mcp/tools/async_rename.py)\n1. Validate both old_path and new_path via PathValidator\n2. Check old_path exists (FILE_NOT_FOUND if not)\n3. If overwrite=false, check new_path does NOT exist (FILE_EXISTS if it does)\n4. Acquire dual write locks via lock_manager.acquire_dual_write(old_path, new_path, timeout) - this already handles alphabetical ordering for deadlock prevention\n5. If expected_hash provided: read old_path bytes, compute hash, compare. On mismatch, return ContentionResponse. Release both locks.\n6. Create parent directories for new_path if create_dirs=true\n7. Call safe_rename(old_path, new_path) from core.file_io - this handles cross-filesystem fallback (copy+fsync+delete) and returns bool indicating cross_filesystem\n8. Update HashRegistry: remove old_path entry, compute/add new_path entry (hash unchanged since content is same)\n9. Release both locks\n10. Return RenameSuccessResponse with cross_filesystem flag\n\n## async_append (src/async_crud_mcp/tools/async_append.py)\n1. Validate path via PathValidator\n2. Check file existence:\n   - If not exists and create_if_missing=false: return FILE_NOT_FOUND\n   - If not exists and create_if_missing=true: create parent dirs if create_dirs=true, create empty file\n3. Acquire exclusive write lock with timeout (FIFO)\n4. Encode separator + content to bytes\n5. Open file in append binary mode ('ab'), write encoded bytes\n6. Fsync the file for durability\n7. Read full file to compute new hash (or compute incrementally)\n8. Update HashRegistry with new hash\n9. Release write lock\n10. Return AppendSuccessResponse with bytes_appended and total_size_bytes\n\n## Module registration (src/async_crud_mcp/tools/__init__.py)\nAdd imports and __all__ exports for async_delete, async_rename, async_append.\n\n## Tests\nCreate three test files following the test_async_write.py pattern:\n- tests/test_tools/test_async_delete.py\n- tests/test_tools/test_async_rename.py\n- tests/test_tools/test_async_append.py\n\nEach test file uses pytest fixtures for temp_base_dir, path_validator, lock_manager, hash_registry. Test classes organized by success/error/edge cases.",
    "files_to_modify": [
      "src/async_crud_mcp/tools/async_delete.py",
      "src/async_crud_mcp/tools/async_rename.py",
      "src/async_crud_mcp/tools/async_append.py",
      "src/async_crud_mcp/tools/__init__.py",
      "tests/test_tools/test_async_delete.py",
      "tests/test_tools/test_async_rename.py",
      "tests/test_tools/test_async_append.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-10.1": "async_delete with optional expected_hash contention check. Implementation: After acquiring write lock, if expected_hash is provided, read file bytes and compute current hash. If mismatch, read file content, build ContentionResponse using compute_diff() (comparing empty string expected-delete vs current content). The diff shows what the file currently contains that differs from what was expected. Return contention response and release lock. If hash matches or no expected_hash, proceed with os.unlink(), hash_registry.remove(), return DeleteSuccessResponse with deleted_hash. Error codes: FILE_NOT_FOUND, PATH_OUTSIDE_BASE, LOCK_TIMEOUT, DELETE_ERROR, SERVER_ERROR.",
      "AC-10.2": "async_rename with dual-lock in alphabetical order. Implementation: Use lock_manager.acquire_dual_write(str(validated_old), str(validated_new), timeout) which already sorts paths alphabetically before acquiring. This prevents deadlocks between concurrent renames (e.g., rename A->B and B->A simultaneously). On LockTimeout from either lock, the method automatically releases the first lock. Both locks released in finally block via release_write for each path.",
      "AC-10.3": "async_rename cross-filesystem fallback. Implementation: Call safe_rename(str(validated_old), str(validated_new)) from core.file_io module. This function checks st_dev of source vs destination directory. Same filesystem: uses atomic os.replace with Windows retry. Different filesystem: uses shutil.copy2 + fsync + os.unlink (not atomic). Returns bool indicating cross_filesystem. The RenameSuccessResponse model already has cross_filesystem: bool field. Pass the return value of safe_rename to the response.",
      "AC-10.4": "async_append with no contention detection, additive semantics. Implementation: No expected_hash parameter in AsyncAppendRequest (already defined). Simply acquire write lock, open file in append mode ('ab'), write separator_bytes + content_bytes. The PRD explicitly states 'No expected_hash parameter. Appends are inherently additive -- they don't conflict with other appends.' After appending, read full file to compute new hash for registry. No ContentionResponse possible for this tool.",
      "AC-10.5": "async_append create_if_missing and separator support. Implementation: Before acquiring lock, check file existence. If not exists and create_if_missing=true, create parent dirs (if create_dirs=true) via os.makedirs(exist_ok=True), then create empty file. If not exists and create_if_missing=false, return FILE_NOT_FOUND error. Separator handling: encode separator string to bytes, prepend to content bytes before writing. If file is empty (new or zero-length), skip separator to avoid leading separator. The separator field defaults to '' (empty string) in the request model."
    },
    "testing_strategy": "Three test files following the established pattern in test_async_write.py:\n\n1. test_async_delete.py:\n   - TestAsyncDeleteSuccess: delete existing file, delete with matching expected_hash, verify hash_registry removal\n   - TestAsyncDeleteContention: delete with mismatching expected_hash returns ContentionResponse with diff\n   - TestAsyncDeleteErrors: file not found, path outside base, lock timeout (mock), OS delete error\n\n2. test_async_rename.py:\n   - TestAsyncRenameSuccess: basic rename, rename with create_dirs, rename with overwrite=true, rename with matching expected_hash\n   - TestAsyncRenameContention: rename with mismatching expected_hash returns ContentionResponse\n   - TestAsyncRenameDualLock: verify alphabetical lock ordering (can test by checking lock_manager state)\n   - TestAsyncRenameErrors: source not found, dest exists (overwrite=false), path outside base, lock timeout\n   - TestAsyncRenameCrossFilesystem: mock os.stat to simulate different st_dev values, verify cross_filesystem=true in response\n\n3. test_async_append.py:\n   - TestAsyncAppendSuccess: append to existing file, append with separator, verify bytes_appended and total_size_bytes\n   - TestAsyncAppendCreateIfMissing: create_if_missing=true creates file, create_if_missing=false returns error\n   - TestAsyncAppendCreateDirs: create_dirs=true creates parent directories\n   - TestAsyncAppendSeparator: separator prepended to content, separator skipped on empty file\n   - TestAsyncAppendErrors: file not found (create_if_missing=false), path outside base, lock timeout, encoding error\n\nAll tests use pytest.mark.asyncio, tempfile.TemporaryDirectory fixtures, and follow the pattern of creating request objects, calling the tool function with injected dependencies, and asserting on response fields.",
    "dependencies": []
  }
}
