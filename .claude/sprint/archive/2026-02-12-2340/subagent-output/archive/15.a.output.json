{
  "story_id": "15",
  "phase": "a",
  "status": "passed",
  "completed_at": "2026-02-12T12:00:00Z",
  "planning_output": {
    "implementation_plan": "Create `src/async_crud_mcp/core/persistence.py` implementing optional state persistence for the hash registry and lock manager pending queue entries. The module centers on a `StatePersistence` class that orchestrates loading, saving, and startup recovery of persisted state.\n\n## Architecture\n\nThe `StatePersistence` class holds references to a `HashRegistry` and a `LockManager`, coordinates debounced writes to `{DATA_DIR}/state.json`, and performs startup recovery (TTL purge + hash re-validation).\n\n### State File Format (`state.json`)\n```json\n{\n  \"version\": 1,\n  \"saved_at\": \"2026-02-12T12:00:00Z\",\n  \"hash_registry\": {\n    \"/normalized/path/to/file.py\": \"sha256:abc123...\"\n  },\n  \"pending_queue\": {\n    \"/normalized/path/to/file.py\": {\n      \"active_readers\": 0,\n      \"active_writer\": false,\n      \"queue\": [\n        {\n          \"request_id\": \"uuid\",\n          \"lock_type\": \"write\",\n          \"created_at\": 12345.67,\n          \"timeout\": 30.0,\n          \"ttl_expires_at\": 12405.67\n        }\n      ]\n    }\n  }\n}\n```\n\n### Debounced Write Mechanism\nUse an asyncio-based debounce: when `mark_dirty()` is called, schedule a write after `write_debounce_seconds`. If another `mark_dirty()` arrives before the timer fires, reset the timer. This ensures at most one write per debounce interval. Implementation uses `asyncio.get_event_loop().call_later()` with a cancel/reschedule pattern.\n\n### Startup Recovery Flow\n1. Read `state.json` from disk (if exists)\n2. Restore hash registry via `HashRegistry.restore()`\n3. Restore lock manager state via `LockManager.restore()`\n4. Call `LockManager.purge_expired()` to remove TTL-expired entries\n5. For each entry in the hash registry, call `compute_file_hash()` on the actual file:\n   - If file exists and hash matches: keep entry\n   - If file exists and hash differs: update with new hash, log warning\n   - If file doesn't exist: remove from registry, log info\n6. Save cleaned state back to disk\n\n### Enable/Disable Toggle\nWhen `persistence.enabled = false` (default), the `StatePersistence` instance is a no-op: `load()` returns immediately, `mark_dirty()` does nothing, `save()` does nothing. All methods are safe to call regardless of enabled state.\n\n### Integration Points\n- The `StatePersistence` instance is created during server bootstrap (Story 13)\n- HashRegistry and LockManager are passed to `StatePersistence.__init__()`\n- After any hash registry update or lock state change, callers invoke `persistence.mark_dirty()`\n- On graceful shutdown, `persistence.save_now()` forces an immediate write",
    "files_to_modify": [
      "src/async_crud_mcp/core/persistence.py",
      "src/async_crud_mcp/core/__init__.py",
      "tests/test_persistence.py"
    ],
    "estimated_complexity": "medium",
    "ac_breakdown": {
      "AC-15.1": "Implement `save()` method that serializes `HashRegistry.snapshot()` into `state.json` at the configured path (default: `get_data_dir() / 'state.json'`, overridable via `PersistenceConfig.state_file`). Use `atomic_write()` from `file_io.py` for crash-safe writes. The state file includes a `version` field (integer, currently 1) and ISO8601 `saved_at` timestamp. On `load()`, read the JSON file and call `HashRegistry.restore()` with the `hash_registry` section. The state file path is resolved at init time: if `config.persistence.state_file` is not None, use that path; otherwise use `get_data_dir() / 'state.json'`. Ensure the parent directory is created with `mkdir(parents=True, exist_ok=True)` before writing.",
      "AC-15.2": "Serialize lock manager queue state via `LockManager.snapshot()` into the `pending_queue` key of `state.json`. This captures queue metadata (request_id, lock_type, created_at, timeout, ttl_expires_at) but NOT file content. On `load()`, call `LockManager.restore()` with the `pending_queue` section. Active readers/writers are also persisted to enable proper queue promotion on restart. Note: `LockManager.snapshot()` and `restore()` already exist and handle the serialization format.",
      "AC-15.3": "After restoring lock manager state on startup, call `LockManager.purge_expired()` which removes entries whose `ttl_expires_at` < current monotonic time. Log the number of purged entries at INFO level using loguru. The TTL multiplier is configured via `PersistenceConfig.ttl_multiplier` (default 2.0) and is already wired into `LockManager.__init__()`. Note: monotonic timestamps from a previous process are meaningless after restart, so the purge effectively clears ALL entries with finite TTL on restart (which is the correct safety behavior - prevents orphaned locks).",
      "AC-15.4": "During startup recovery after loading state, iterate over all entries in the restored hash registry. For each (path, hash) pair: (1) Check if file exists on disk. If not, remove from registry and log at INFO level. (2) If file exists, call `compute_file_hash(path)` and compare with stored hash. If mismatch, update the registry with the new hash and log at WARNING level (indicates external modification). (3) If file exists and hash matches, keep as-is. This re-validation loop runs once at startup, not on every save. Handle OSError/PermissionError gracefully per file (log and skip, don't abort entire recovery).",
      "AC-15.5": "Implement debounced writes using an asyncio-based timer pattern. The `StatePersistence` class has a `mark_dirty()` method that: (1) Sets an internal `_dirty` flag. (2) If no pending timer, schedules `_do_save()` via `asyncio.get_event_loop().call_later(write_debounce_seconds, ...)`. (3) If a timer is already pending, cancel it and reschedule. This ensures writes happen at most once per `write_debounce_seconds` (default 1.0s). Also provide `save_now()` for immediate flush (used during graceful shutdown). The debounce timer handle is stored as `_save_handle: Optional[asyncio.TimerHandle]`.",
      "AC-15.6": "The `StatePersistence.__init__()` accepts a `PersistenceConfig` (from `config.py`, already defined with `enabled: bool = False`). When `enabled=False`: `load()` is a no-op, `mark_dirty()` is a no-op, `save()` is a no-op, `save_now()` is a no-op. All public methods check `self._enabled` first and return immediately if disabled. The `enabled` flag is read once at construction time. Export `StatePersistence` from `core/__init__.py`."
    },
    "testing_strategy": "Create `tests/test_persistence.py` with the following test cases:\n\n1. **test_save_and_load_hash_registry**: Create a StatePersistence with a HashRegistry containing entries, call save_now(), create a new instance, call load(), verify registry state matches.\n\n2. **test_save_and_load_pending_queue**: Create a StatePersistence with a LockManager that has queued entries, save and reload, verify queue metadata is preserved.\n\n3. **test_ttl_purge_on_startup**: Persist lock entries with expired TTLs, load into new instance, verify purge_expired removes them.\n\n4. **test_hash_revalidation_file_exists_match**: Persist hashes, ensure files exist on disk with matching content, load and verify hashes unchanged.\n\n5. **test_hash_revalidation_file_exists_mismatch**: Persist hashes, modify files on disk, load and verify hashes updated to new values.\n\n6. **test_hash_revalidation_file_deleted**: Persist hashes for files, delete the files, load and verify entries removed from registry.\n\n7. **test_debounced_writes**: Call mark_dirty() multiple times rapidly, verify only one write occurs within the debounce window using file modification time or write count.\n\n8. **test_disabled_persistence_noop**: Create StatePersistence with enabled=False, verify load/save/mark_dirty are no-ops (no file created).\n\n9. **test_custom_state_file_path**: Configure a custom state_file path, verify state.json is written there instead of default DATA_DIR.\n\n10. **test_corrupt_state_file**: Write invalid JSON to state.json, verify load() handles it gracefully (logs error, starts fresh).\n\n11. **test_save_now_flushes_immediately**: Verify save_now() writes state immediately regardless of debounce timer.\n\nAll tests use tmp_path fixture for isolated state file locations. Use pytest-asyncio for async test methods.",
    "dependencies": []
  }
}
