# Plan: Path-Based Access Control for Destructive Operations

## Context

Investigated the async-crud-mcp MCP server and the claude-code-tooling/claude-commands framework to design a path-based access control (whitelist/blacklist) system for destructive MCP tool operations (write, update, delete, append, rename, batch-write, batch-update). The current architecture uses coarse tool-level allow/deny via `plan-settings.json`, but subagents dispatched for sprint story implementation need to write output files to `.claude/sprint/subagent-output/` while being blocked from modifying source files elsewhere. The goal is MCP-level guardrails that are more granular than the current binary tool ban approach.

---

## Findings

### async-crud-mcp Architecture

**Server entry point**: `src/async_crud_mcp/server.py:57-65`

The server creates a `FastMCP` instance and initializes three shared dependencies at module level:
- `PathValidator(base_directories=settings.crud.base_directories)` — controls which base dirs are accessible at all
- `LockManager` — per-file async exclusive/shared locking
- `HashRegistry` — conflict detection via hash tracking

All 11 tool wrappers (`async_write_tool`, `async_update_tool`, `async_delete_tool`, etc.) are `@mcp.tool()` decorated coroutines that directly pass the shared `path_validator` and `lock_manager` to tool functions.

**Destructive tools** (those that modify or delete files): `async_write`, `async_update`, `async_delete`, `async_append`, `async_rename`, `async_batch_write`, `async_batch_update` — 7 of the 11 tools.

Read-only tools: `async_read`, `async_batch_read`, `async_list`, `async_status` — 4 tools.

**Current path validation** (`src/async_crud_mcp/core/path_validator.py:18-133`):

`PathValidator` implements a **global whitelist**: `base_directories` defines which root directories are accessible at all. If `base_directories` is empty, all paths are allowed. The `validate()` method resolves symlinks, normalizes the path, and checks whether it falls under any listed base directory. This enforces **read AND write** restrictions equally — there is no per-operation differentiation.

The validation occurs as step 1 inside every tool function (e.g., `async_write.py:40-46`), before lock acquisition. A `PathValidationError` is caught and returned as `ErrorResponse(error_code=ErrorCode.PATH_OUTSIDE_BASE, ...)`.

**Configuration system** (`src/async_crud_mcp/config.py:68-76`):

`CrudConfig` has `base_directories: list[str]` field. The `Settings` class supports JSON config file loading (via `Settings.from_file()`) and environment variables (`ASYNC_CRUD_MCP_CRUD__BASE_DIRECTORIES`). This is the natural extension point for adding per-operation access control rules.

**Tool function signatures** (e.g., `async_write.py:19-24`):

All destructive tools take `(request, path_validator, lock_manager, hash_registry)` as positional arguments. `path_validator` is a plain Python object passed by reference — no interface/ABC in place. This makes it straightforward to substitute a subclass without touching tool implementations.

**Error codes** (`src/async_crud_mcp/models/responses.py:11-27`):

`ErrorCode.PATH_OUTSIDE_BASE` already exists and is semantically appropriate for blocked access control denials. A new `ACCESS_DENIED` error code also exists but is unused.

### claude-code-tooling/claude-commands Architecture

**Current tool restriction mechanism** (`resources/commands/context/SSOT/plan-settings.json`):

The file specifies a binary allow/deny list at the **tool name level**. There is no path-level restriction support in the current schema. The current policy is:
- Allow: `Read`, `Glob`, `Grep`, `LSP`, `WebSearch`, `WebFetch`, `Write`
- Deny: `Edit`, `Bash`, `NotebookEdit`, `Task`, `TaskOutput`

This allows `Write` globally — the v2.2.0 release notes describe the intent as `Write(.claude/subagents/plans/*)` but the actual JSON does not enforce path constraints. The path restriction is documented as a behavioral instruction in the prompt text, not as a mechanically enforced guardrail.

**Subagent output file pattern** (from `story-phase-b-implementation.md:16,23`):

Sprint story subagents are ALLOWED to: write phase output JSON to `.claude/sprint/subagent-output/`. They are PROHIBITED from writing outside the project source tree and `.claude/sprint/subagent-output/`. This is currently enforced only via prompt instructions — the native `Write` tool is globally allowed and there is no MCP-level path guard.

**Dispatch mechanism** (`commands/context/PLAN.md:146`):

Subagents are dispatched via `env -u CLAUDECODE $CLAUDE_CLI -p --settings plan-settings.json --model {MODEL}`. The `--settings` flag is how tool policies are injected. The CLI `--settings` mechanism only supports tool-level allow/deny today (per the plan-settings.json schema observed).

**Key limitation**: Native Claude Code tools (`Write`, `Edit`, `Bash`) operate outside the async-crud-mcp MCP server. Restrictions on those must be enforced by Claude's permissions layer, not by the MCP server. However, when subagents are instructed to use `async_write_tool` via MCP instead of native `Write`, the MCP server CAN enforce path-level restrictions.

---

## Recommendations

### Core Design: Extend PathValidator with Operation-Type Awareness

**Recommended approach**: Add an `AccessPolicy` class to `src/async_crud_mcp/core/path_validator.py` (or a new `src/async_crud_mcp/core/access_policy.py`) that wraps `PathValidator` with per-operation-type path rules. The `PathValidator` base whitelist remains unchanged; the `AccessPolicy` layer adds finer-grained allow/deny on top.

**Operation categories**:
- `read`: `async_read`, `async_batch_read`, `async_list`, `async_status`
- `write`: `async_write`, `async_batch_write`, `async_append`
- `update`: `async_update`, `async_batch_update`
- `delete`: `async_delete`
- `rename`: `async_rename` (affects both source and destination)

**AccessPolicy data structure** (to be added to `CrudConfig`):

```python
class PathRule(BaseModel):
    path: str          # Pattern (prefix match or glob)
    operations: list[str]  # ["write", "update", "delete", "rename"] or ["*"]
    action: Literal["allow", "deny"]
    priority: int = 0  # Higher = evaluated first

class CrudConfig(BaseModel):
    base_directories: list[str] = []
    access_rules: list[PathRule] = []   # NEW
    default_destructive_policy: Literal["allow", "deny"] = "allow"  # NEW
```

**Rule evaluation**: First-match wins (ordered by priority descending). If no rule matches, `default_destructive_policy` applies. For read operations, rules are not evaluated (read remains controlled only by `base_directories`).

**Implementation path**:

1. **`src/async_crud_mcp/config.py`** (`CrudConfig`, L68-76): Add `access_rules: list[PathRule] = []` and `default_destructive_policy` fields.

2. **`src/async_crud_mcp/core/path_validator.py`** (new method or subclass): Add `validate_operation(path, operation_type) -> Path` that calls base `validate()` first, then checks access rules. The method signature matches the existing `validate()` convention.

3. **`src/async_crud_mcp/server.py`** (L61): Pass `settings.crud.access_rules` and `settings.crud.default_destructive_policy` when constructing the validator or a new `AccessPolicy` wrapper.

4. **Tool functions** (e.g., `async_write.py:40-46`, `async_delete.py`, etc.): Change `path_validator.validate(request.path)` to `path_validator.validate_operation(request.path, "write")`. Since tool functions receive `path_validator` by reference, no server.py wiring changes needed beyond the constructor.

5. **`src/async_crud_mcp/models/responses.py`** (`ErrorCode`): Repurpose or alias `ACCESS_DENIED` for operation-type denials (currently unused).

### Complementing the CLI Tool-Ban Approach

For subagents that SHOULD use async-crud-mcp for all writes (not native `Write`):
- Configure `plan-settings.json` to **deny native Write** and instead use `async_write_tool` via MCP
- Set MCP access rules to allow `write` only in `.claude/subagents/plans/` and `.claude/sprint/subagent-output/`
- This creates a two-layer guard: CLI denies native Write, MCP allows it only to designated directories

For subagents that need unrestricted source code modification (sprint implementation phase):
- Keep native `Write`/`Edit` allowed (for broad editing capability)
- The MCP path restriction only applies when the agent explicitly uses async-crud-mcp tools

### Risks and Trade-offs

- **Pattern complexity**: Glob patterns in `access_rules` require careful implementation (use `pathlib.Path.match()` or `fnmatch`). Prefix-matching is simpler and covers the primary use case.
- **Batch operations**: `async_batch_write` and `async_batch_update` contain multiple paths. Each item must be individually checked; the batch should fail-fast or per-item depending on desired behavior. Current batch tools iterate individually — add per-item `validate_operation()` calls.
- **Rename edge case**: Both `old_path` (delete) and `new_path` (write) need separate rule checks.
- **Backward compatibility**: `access_rules: list[PathRule] = []` with `default_destructive_policy = "allow"` means no behavior change when rules are omitted. Fully backward compatible.

---

## Files Identified

| File | Lines | Relevance |
|------|-------|-----------|
| `src/async_crud_mcp/config.py` | L68-76 | Add `PathRule` model and `access_rules`/`default_destructive_policy` to `CrudConfig` |
| `src/async_crud_mcp/core/path_validator.py` | L18-133 | Extend `PathValidator` with `validate_operation(path, op_type)` method; add rule evaluation logic |
| `src/async_crud_mcp/core/__init__.py` | L1-27 | Export new types if `AccessPolicy` or `PathRule` split to separate module |
| `src/async_crud_mcp/server.py` | L57-65, L145-146 | Pass access rules to `PathValidator` constructor; no tool wrapper changes needed |
| `src/async_crud_mcp/tools/async_write.py` | L40-46 | Change `validate()` to `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_update.py` | (same pattern as write) | Change to `validate_operation(path, "update")` |
| `src/async_crud_mcp/tools/async_delete.py` | (same pattern as write) | Change to `validate_operation(path, "delete")` |
| `src/async_crud_mcp/tools/async_append.py` | (same pattern as write) | Change to `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_rename.py` | (same pattern) | Check `old_path` as "delete", `new_path` as "write" |
| `src/async_crud_mcp/tools/async_batch_write.py` | (per-item loop) | Per-item `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_batch_update.py` | (per-item loop) | Per-item `validate_operation(path, "update")` |
| `src/async_crud_mcp/models/responses.py` | L11-27 | Repurpose `ACCESS_DENIED` for path-rule denials; add descriptive message |
| `tests/test_path_validator.py` | L1-60+ | Add tests for `validate_operation()` with allow/deny rules |
| `resources/commands/context/SSOT/plan-settings.json` | L1-21 | Add `deny: Write` for plan-mode subagents (use MCP instead of native Write) |
| `resources/commands/sprint/delegates/story-phase-b-implementation.md` | L9-23 | Document MCP-level path rules for subagent output directories |
