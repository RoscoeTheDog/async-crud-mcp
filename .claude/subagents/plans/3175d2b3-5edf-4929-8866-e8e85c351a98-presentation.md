# Plan: Path-Based Access Control for Destructive Operations

## Context

**Problem**: The async-crud-mcp MCP server currently restricts access only at the global `base_directories` level, with no per-operation-type differentiation. Subagents dispatched for sprint tasks need to write output files to `.claude/sprint/subagent-output/` while being blocked from modifying source files elsewhere. Today, the system relies on prompt instructions rather than mechanically enforced guardrails.

**Solution**: Extend `PathValidator` with operation-type awareness by introducing an `AccessPolicy` layer that evaluates per-operation path rules (allow/deny for write, update, delete, rename, append). Rules are evaluated in priority order; first match wins. This adds MCP-level path-based guardrails without breaking backward compatibility.

## Changes

### File: `src/async_crud_mcp/config.py` (L68-76)
- **Currently**: `CrudConfig` has only `base_directories: list[str]` field.
- **Change**: Add two new fields:
  - `access_rules: list[PathRule] = []` — list of per-operation path rules
  - `default_destructive_policy: Literal["allow", "deny"] = "allow"` — fallback policy when no rule matches
- **Why**: Centralizes access policy configuration alongside base directory restrictions. `PathRule` model defines `path` (prefix/glob pattern), `operations` (list of operation types), `action` ("allow"/"deny"), and `priority` (evaluation order).

### File: `src/async_crud_mcp/core/path_validator.py` (L18-133)
- **Currently**: `PathValidator.validate()` only checks against `base_directories`.
- **Change**: Add `validate_operation(path, operation_type)` method that:
  1. Calls base `validate()` first (preserves existing whitelist logic)
  2. Evaluates access rules in priority order (highest first)
  3. Returns first matching rule's action; falls back to `default_destructive_policy`
  4. For read operations, only `base_directories` applies (no rule filtering)
- **Why**: Preserves backward compatibility while enabling granular per-operation control.

### File: `src/async_crud_mcp/server.py` (L57-65, L145-146)
- **Currently**: Passes only `base_directories` to `PathValidator` constructor.
- **Change**: Also pass `settings.crud.access_rules` and `settings.crud.default_destructive_policy` from config.
- **Why**: Wires the new configuration into the validator at server startup.

### File: `src/async_crud_mcp/tools/async_*.py` (destructive tools)
- **Currently**: All call `path_validator.validate(request.path)` generically.
- **Change**: Replace with operation-type-specific calls:
  - `async_write.py` (L40-46): `path_validator.validate_operation(request.path, "write")`
  - `async_update.py`: → `"update"`
  - `async_delete.py`: → `"delete"`
  - `async_append.py`: → `"write"` (appends are writes)
  - `async_rename.py`: Check `old_path` as `"delete"` and `new_path` as `"write"`
  - `async_batch_write.py`, `async_batch_update.py`: Per-item validation in iteration loop
- **Why**: Enables rule-based filtering at the tool level without server.py wiring changes.

### File: `src/async_crud_mcp/models/responses.py` (L11-27)
- **Currently**: `ErrorCode.ACCESS_DENIED` exists but is unused; `PATH_OUTSIDE_BASE` used for validation failures.
- **Change**: Use `ACCESS_DENIED` error code (with descriptive message) when a path-rule blocks an operation.
- **Why**: Semantically distinguishes path-rule violations from base-directory violations.

### File: `src/async_crud_mcp/core/__init__.py` (L1-27)
- **Currently**: Exports core classes.
- **Change**: Export new `PathRule` and `AccessPolicy` types if split into separate module.
- **Why**: Maintains module organization if access policy logic moves to dedicated file.

### File: `tests/test_path_validator.py` (L1-60+)
- **Currently**: Tests only base `validate()` method against `base_directories`.
- **Change**: Add tests for `validate_operation()` covering:
  - Allow rules blocking specific operations
  - Deny rules passing through default policy
  - Priority ordering (higher priority first)
  - Batch operations with mixed results
  - Rename edge case (both old_path delete + new_path write checks)
- **Why**: Ensures correctness of new access policy logic.

## Files to Modify

| File | Change |
|------|--------|
| `src/async_crud_mcp/config.py` | Add `PathRule` model and `access_rules`, `default_destructive_policy` fields to `CrudConfig` |
| `src/async_crud_mcp/core/path_validator.py` | Add `validate_operation(path, op_type)` method with rule evaluation logic |
| `src/async_crud_mcp/core/__init__.py` | Export `PathRule` and new policy types |
| `src/async_crud_mcp/server.py` | Pass access_rules to `PathValidator` constructor |
| `src/async_crud_mcp/tools/async_write.py` | Replace `validate()` with `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_update.py` | Replace `validate()` with `validate_operation(path, "update")` |
| `src/async_crud_mcp/tools/async_delete.py` | Replace `validate()` with `validate_operation(path, "delete")` |
| `src/async_crud_mcp/tools/async_append.py` | Replace `validate()` with `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_rename.py` | Check old_path as "delete", new_path as "write" |
| `src/async_crud_mcp/tools/async_batch_write.py` | Per-item `validate_operation()` calls |
| `src/async_crud_mcp/tools/async_batch_update.py` | Per-item `validate_operation()` calls |
| `src/async_crud_mcp/models/responses.py` | Use `ACCESS_DENIED` for path-rule denials |
| `tests/test_path_validator.py` | Add tests for `validate_operation()` with rules and priority |

## Verification

1. Create a test config with `access_rules` allowing write only to `.claude/sprint/subagent-output/` and deny all other writes.
2. Call `validate_operation(path="/some/source/file.py", "write")` — should raise `ACCESS_DENIED` error.
3. Call `validate_operation(path=".claude/sprint/subagent-output/result.json", "write")` — should pass validation.
4. Verify priority ordering: define two overlapping rules at different priorities, confirm higher priority is evaluated first.
5. Test batch operations: submit `async_batch_write` with mixed paths (some allowed, some denied), confirm per-item validation and expected failure behavior.
6. Test backward compatibility: omit `access_rules` from config, confirm all destructive operations pass (default `allow` policy).
7. Test rename edge case: `async_rename` old_path fails "delete" check, new_path passes "write" check — operation should fail.

## Key Design Decisions

- **First-match-wins rule evaluation**: Simplifies reasoning about conflicts and avoids ambiguous multi-rule scenarios.
- **Read operations unfiltered**: Only `base_directories` applies to reads; destructive operations get rule filtering on top. Rationale: read access is lower-risk and already controlled at the root-directory level.
- **Backward compatible defaults**: `access_rules: []` and `default_destructive_policy: "allow"` mean existing deployments see no behavior change.
- **Per-item batch handling**: Batch tools fail-fast (stop at first violation) to maintain consistency with synchronous error reporting.

## NOT Modified

- Native Claude Code tools (`Write`, `Edit`) — remain subject to CLI-level `plan-settings.json` restrictions
- `PathValidator.validate()` base method — unchanged; new `validate_operation()` builds on top
- Tool signatures — no changes to function parameters or return types
