# Plan: Path-Based Access Control for Destructive Operations (Revised v2)

## Context

Investigated the full config loading chain, tool validate() call sites, and the env var propagation
mechanism for Claude Code CLI subagent sessions. The key correction from feedback: the primary
client is Claude Code CLI (not Claude Desktop), and subagents launched with `$CLAUDE_CLI -p
--settings <file>` each spawn their OWN MCP server process, so env vars in the `--settings` file
propagate directly to the subagent's MCP server instance at startup.

---

## Findings

### 1. get_settings() Env Var Loading Chain

`config.py:177-210`: `get_settings()` is a singleton that returns a cached `Settings` instance.
`Settings` (L118-174) uses `pydantic-settings` with `env_prefix="ASYNC_CRUD_MCP_"` and
`env_nested_delimiter="__"`. Priority order is: env vars > JSON config file > defaults
(see `settings_customise_sources`, L154-174).

Key point: there is NO existing `ASYNC_CRUD_MCP_ACCESS_POLICY` env var. Adding it requires:
- Adding a `policy_file: str | None = None` field to `CrudConfig` (L68-76) OR
- Adding a top-level `access_policy_file: str | None = None` to `Settings` (L118-135)
- Reading this field in `get_settings()` AFTER the Settings instance is created, to load the
  external policy JSON and merge `access_rules` into the settings

The cleanest approach: add `access_policy_file` directly to `CrudConfig` so it lives under the
`crud` section. It would be settable as `ASYNC_CRUD_MCP_CRUD__ACCESS_POLICY_FILE=/path/policy.json`.

### 2. Claude Code CLI Env Var Propagation

The `--settings` file for `$CLAUDE_CLI -p` supports an `"env"` block (confirmed by user feedback).
These env vars are injected into the spawned process environment. Since each `$CLAUDE_CLI -p`
invocation spawns a fresh MCP server subprocess, the env block in `plan-settings.json` reaches the
MCP server's `os.environ` at startup before `get_settings()` is called. This makes env vars the
correct injection mechanism.

Concrete propagation path:
```
plan-settings.json "env" block
  -> $CLAUDE_CLI -p subprocess env
    -> MCP server subprocess env (inherited)
      -> os.environ["ASYNC_CRUD_MCP_CRUD__ACCESS_POLICY_FILE"] = ".claude/access-policies/planner.json"
        -> pydantic-settings reads it as settings.crud.access_policy_file
          -> get_settings() post-processes: loads policy file, builds PathRule list
```

### 3. Tool validate() Call Sites (Exact Locations)

All 7 destructive tools have the same pattern - `path_validator.validate(request.path)` at line ~40-47
of each file, catching `PathValidationError` and returning `ErrorCode.PATH_OUTSIDE_BASE`.

Specific locations:
- `async_write.py:40` - `validated_path = path_validator.validate(request.path)`
- `async_update.py:57` - `validated_path = path_validator.validate(request.path)`
- `async_delete.py:47` - `validated_path = path_validator.validate(request.path)`
- `async_append.py:44` - `validated_path = path_validator.validate(request.path)`
- `async_rename.py:48-49` - validates BOTH `request.old_path` and `request.new_path`
- `async_batch_write.py:53` - delegates to `async_write()`, which calls validate internally
- `async_batch_update.py` - delegates to `async_update()`, which calls validate internally

The batch tools delegate to single-file functions, so adding access control to the single-file
functions automatically covers batch operations.

### 4. Rename Dual-Path Semantics

`async_rename.py:48-49` validates both paths in ONE try block (L46-55). For access rules:
- `old_path` requires "delete" permission (source being removed)
- `new_path` requires "write" permission (destination being created)

These must be checked separately with different operation types, so the rename tool needs two
independent `validate_operation()` calls, each with its own error return.

### 5. Existing ErrorCode.ACCESS_DENIED

`models/responses.py:16` already defines `ErrorCode.ACCESS_DENIED = "ACCESS_DENIED"`. This is the
correct code for policy denials (distinct from `PATH_OUTSIDE_BASE` which is for base directory
violations).

### 6. PathValidator Constructor in server.py

`server.py:61`: `path_validator = PathValidator(base_directories=settings.crud.base_directories)`

This is the single instantiation point. To add access rules, the constructor must receive the
rules list. The rules are available from settings, loaded at startup. No changes to the tool
function signatures are needed - they all accept `PathValidator` by reference.

---

## Recommendations

### Hierarchical Config Design

Three levels, higher overrides lower:

**Level 1 (Global default)**: `%LOCALAPPDATA%/async-crud-mcp/config/config.json`
```json
{
  "crud": {
    "default_destructive_policy": "allow",
    "access_rules": []
  }
}
```

**Level 2 (Project policy file)**: `.claude/access-policies/planner.json` (committed to repo)
```json
{
  "default_destructive_policy": "deny",
  "access_rules": [
    {"path": "/project/.claude/subagents/plans", "operations": ["write"], "action": "allow", "priority": 100},
    {"path": "/project/.claude/research", "operations": ["write", "append"], "action": "allow", "priority": 90}
  ]
}
```

**Level 3 (Session)**: `plan-settings.json` env block selects which Level 2 file to load:
```json
{
  "env": {
    "ASYNC_CRUD_MCP_CRUD__ACCESS_POLICY_FILE": ".claude/access-policies/planner.json"
  },
  "permissions": {
    "allow": ["mcp__async-crud-mcp__async_write_tool", "Read", "Glob", "Grep"],
    "deny": ["Edit", "Bash", "NotebookEdit", "Task"]
  }
}
```

The policy file path is resolved relative to `os.getcwd()` (the Claude session's PWD), making
it project-scoped automatically.

### Concrete Policy Examples

**(a) Planner policy** - write only to plan output dirs:
```json
{
  "default_destructive_policy": "deny",
  "access_rules": [
    {"path": ".claude/subagents/plans", "operations": ["write"], "action": "allow", "priority": 100},
    {"path": ".claude/research", "operations": ["write", "append"], "action": "allow", "priority": 90}
  ]
}
```

**(b) Sprint implementation policy** - write to sprint output dirs:
```json
{
  "default_destructive_policy": "deny",
  "access_rules": [
    {"path": ".claude/sprint/subagent-output", "operations": ["write", "append"], "action": "allow", "priority": 100},
    {"path": ".claude/sprint/tmp", "operations": ["write", "delete"], "action": "allow", "priority": 90},
    {"path": "src", "operations": ["write", "update", "delete"], "action": "allow", "priority": 80}
  ]
}
```

**(c) Full-access policy** (unrestricted sessions):
```json
{
  "default_destructive_policy": "allow",
  "access_rules": []
}
```

### Rule Evaluation

- Sort rules by `priority` descending, then insertion order as tiebreaker
- First matching rule wins (short-circuit)
- Path matching: prefix match, same normalization as `PathValidator.validate()`
- `operations: ["*"]` matches any destructive operation
- If no rule matches, `default_destructive_policy` applies ("allow" by default for backward compat)
- Read operations (`async_read`, `async_list`, `async_status`, `async_batch_read`) are NEVER subject
  to access rules - only destructive operations go through `validate_operation()`

### No Runtime Config Tool

The agent must NOT be able to modify its own access policy. The policy is immutable for the
session lifetime (loaded once in `get_settings()` before tool registration at `server.py:60-61`).

---

## Implementation Steps

1. **Add `PathRule` model to `config.py`** (insert before `CrudConfig` at L68)
   - Fields: `path: str`, `operations: list[str]`, `action: Literal["allow","deny"]`,
     `priority: int = 0`

2. **Extend `CrudConfig` at `config.py:68-76`**
   - Add `access_rules: list[PathRule] = Field(default_factory=list)`
   - Add `access_policy_file: str | None = None`
   - Add `default_destructive_policy: Literal["allow","deny"] = "allow"`

3. **Extend `get_settings()` at `config.py:177-210`**
   - After creating `Settings` instance, check `settings.crud.access_policy_file`
   - If set, resolve relative to `os.getcwd()`, load JSON, merge `access_rules` and
     `default_destructive_policy` into settings (create new `CrudConfig` instance)
   - This merging must happen BEFORE caching

4. **Add `validate_operation()` to `PathValidator` at `path_validator.py` (after L123)**
   - Signature: `def validate_operation(self, path: str, op_type: str) -> Path`
   - First calls `self.validate(path)` (reuses existing base-dir check)
   - Then applies access rules: resolves path to normalized form, walks sorted rules,
     first match wins
   - Raises `PathValidationError` with ACCESS_DENIED message on deny
   - Returns validated `Path` on allow (same as `validate()`)

5. **Update `PathValidator.__init__()` at `path_validator.py:38`**
   - Add `access_rules: list | None = None` and
     `default_destructive_policy: str = "allow"` parameters
   - Store and pre-sort rules by priority descending at init time

6. **Update `server.py:61`**
   - `path_validator = PathValidator(base_directories=..., access_rules=settings.crud.access_rules, default_destructive_policy=settings.crud.default_destructive_policy)`

7. **Update destructive tools** - change `path_validator.validate()` to `path_validator.validate_operation()`:
   - `async_write.py:40` -> `validate_operation(request.path, "write")`
   - `async_update.py:57` -> `validate_operation(request.path, "update")`
   - `async_delete.py:47` -> `validate_operation(request.path, "delete")`
   - `async_append.py:44` -> `validate_operation(request.path, "write")`
   - `async_rename.py:48` -> two separate calls: `validate_operation(old_path, "delete")` then
     `validate_operation(new_path, "write")`, each in their own try/except returning `ACCESS_DENIED`

8. **Update error responses** in tools - for PathValidationError from `validate_operation()`:
   - Check if message contains "ACCESS_DENIED" sentinel or use a new exception subclass
     `AccessDeniedError(PathValidationError)` to distinguish from base-dir violations
   - Use `ErrorCode.ACCESS_DENIED` for policy denials vs `ErrorCode.PATH_OUTSIDE_BASE` for
     base-dir violations

9. **Export `PathRule` from `core/__init__.py`** (though PathRule is in config.py, not core)
   - Actually PathRule lives in config.py, so export from there directly

10. **Add tests to `tests/test_path_validator.py`**
    - Tests for `validate_operation()` with allow/deny rules
    - Tests for priority ordering (higher priority wins)
    - Tests for default policy fallback
    - Tests for path prefix matching

---

## Files Identified

| File | Lines | Relevance |
|------|-------|-----------|
| `src/async_crud_mcp/config.py` | L12-17 | Add `Literal` import (already present) |
| `src/async_crud_mcp/config.py` | L68-76 | Add `PathRule` model before `CrudConfig`; extend `CrudConfig` with 3 new fields |
| `src/async_crud_mcp/config.py` | L177-210 | Extend `get_settings()` to load policy file after Settings() construction |
| `src/async_crud_mcp/core/path_validator.py` | L38-54 | Add `access_rules`, `default_destructive_policy` params to `__init__()` |
| `src/async_crud_mcp/core/path_validator.py` | L123 (after) | Add `validate_operation()` method |
| `src/async_crud_mcp/core/path_validator.py` | L13-15 | Add `AccessDeniedError(PathValidationError)` subclass |
| `src/async_crud_mcp/core/__init__.py` | L7 | Export `AccessDeniedError` from path_validator |
| `src/async_crud_mcp/server.py` | L61 | Pass `access_rules` + `default_destructive_policy` to `PathValidator` |
| `src/async_crud_mcp/tools/async_write.py` | L40-46 | `validate()` -> `validate_operation(path, "write")`; catch `AccessDeniedError` separately |
| `src/async_crud_mcp/tools/async_update.py` | L57-63 | `validate()` -> `validate_operation(path, "update")` |
| `src/async_crud_mcp/tools/async_delete.py` | L47-53 | `validate()` -> `validate_operation(path, "delete")` |
| `src/async_crud_mcp/tools/async_append.py` | L44-50 | `validate()` -> `validate_operation(path, "write")` |
| `src/async_crud_mcp/tools/async_rename.py` | L46-55 | Split into two separate validate_operation calls with distinct error codes |
| `src/async_crud_mcp/models/responses.py` | L16 | `ACCESS_DENIED` already exists - no change needed |
| `tests/test_path_validator.py` | L1-60+ | Add `validate_operation()` test cases |
